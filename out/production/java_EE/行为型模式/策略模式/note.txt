定义：
该模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响使用算法的客户
策略模式属于对象行为模式，对算法进行封装，把使用算法的责任和算法进行分割开来，并委派给不同的对象进行算法的管理

结构：
抽象策略类：这是一个抽象类，通常由接口或者抽象类实现。此角色给出所有的具体策略类所需要的接口
具体策略类：实现了抽象策略类的接口，提供具体算法实现或者行为
环境类：持有一个策略类的引用，最终给客户端使用（封装算法，不然客户端接触）

优点：
策略类之间可以自由交换，由于策略类都实现同一个接口，所以他们之间可以自由切换
易于扩展：增加一个新的策略只需要增加一个具体的策略类即可，基本不需要更改原有代码，符合开闭原则
能够避免过多的if-else语句，充分体现了面向对象的思想

缺点：
客户端必须知道所有的策略类，并自行决定使用哪个策略类
策略模式将造成产生很多的策略类，可以通过享元模式在一定程度上减少对象的数量

使用场景：
1、一个系统需要动态地在几种算法里面选择一种的时候，可以将每个算法封装到策略类中
2、一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可以将每个条件分支移入他们各自的策略类中以代替这些条件语句
3、系统中各算法完全独立，并且对客服隐藏具体算法实现的细节（封装好了）
4、多个类区别只在表现的行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为

理解：
策略模式主要针对于很多在不同的场所使用不同的方法，如果不是策略模式来写的话，主要使用if-else这样的选择语句进行书写
使用策略模式，把在上面时候需要进行什么样的操作封装起来，到客户端要用的时候直接赋值
比如他的促销案例，在环境类里面进行封装好了，然后在客户端类，需要实现怎么样的操作，直接new对象就行了
