一、介绍
    以前写多线程的弊端
        1、用到线程的时候就创建
        2、用完之后线程消失，这样比较浪费资源
    使用线程池，相当于一个容器，把线程放入其中，需要的时候再取出使用

二、线程池主要核心原理
    1、创建一个池子，里面是空的
    2、提交任务，池子会创建新的线程对象，任务执行完毕，线程归还给池子。等下次在执行任务时，不需要在创建新的线程，直接复用已经存在的线程即可
    3、但是如果提交任务的时候，池子没有空闲，并且无法创建新的线程（设置最大线程数），任务就会排队等待

三、线程池的实现
1、工具类
2、自定义

四、自定义线程池的构造形参
    以https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=164中列举餐馆为例，自定义线程需要的参数有
    1、正式员工数----->核心线程的数量（不能小于0）
    2、餐厅最大员工数---->线程中最大线程的数据(最大数量>=核心线程数)(正式员工+临时员工)
    3、临时员工空闲多长时间被辞退(值)----->空闲时间（值）
    4、临时员工空闲多长时间被辞退 (单位)----->空闲时间单位(使用timeUnit指定)
    5、排队的客户----->阻塞队列(不能为空)
    6、从哪里招人------>创建线程的方式(不能为空)
    7、当排队人数过多，超出顾客请下次再来(拒绝服务)----->要执行任务过多时候的解决方式(不能为空)

五、自定义线程池(任务拒绝策略)
1、ThreadPoolExecutor.AbortPolicy--->(默认)丢弃任务并抛出RejectedExecutionException异常
2、ThreadPoolExecutor.DiscardPolicy--->丢弃任务，但是不抛出异常这是--->不推荐的做法
3、ThreadPoolExecutor.DiscardOldestPolicy--->抛弃队列中等待最久的任务然后把当前任务加入队列中
（在图解自定义线程4中，1，2,3核心线程 10,5,6等待，7,8,9临时线程，4在最前等待最久，抛弃）
4、ThreadPoolExecutor.CallerRunsPolicy--->调用任务的run()方法绕过线程池直接执行


六、自定义线程小结
    1、创建一个空的池子
    2、有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程
    PS:不断的提交任务，会有以下三个临界点:
        --->当核心线程满时，再提交任务就会排队
        ---->当核心线程满，队伍满时，会创建临时线程
        ---->当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略

七、线程池多大合适呢？
    1、CPU密集型运算(逻辑计算较多) ---->最大并行数+1（为什么加1，因为怕有些不能正常运行，加1让其最高效）
    2、I/O密集型运算（文件操作较多，数据库操作等，比较常用）
        --->最大并行数*期望CPU利用率*（CPU计算时间+等待时间）/CPU计算时间

八、向java虚拟机返回可用处理器的数目
    int count=Runtime.getRuntime().availableProcessors();